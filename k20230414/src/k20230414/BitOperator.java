package k20230414;

public class BitOperator {

	public static void main(String[] args) {
		
//		비트 연산자 
//		& : 비트끼리 and, 두 비트가 모두 1이면 1
//		| : 비트끼리 or, 두 비트 중에서 1비트 이상 1이면, 1
//		^ : 비트끼리 xor(배타적 논리합), 두 비트가 다를 때, 1
//		~ : 비트 부정 (논리 부정은 !), 1은 0으로 0은 1로 바꿈 => 1의 보수를 계산할 때 쓰임
		
		
		
//		&
//		0011 11010
//		1100 00111 마스크비트
//		----------
//		0000 00010 => 1과 0의 위치 바뀜
		
//		|
//		0000 0010
//		0010 1100
//		----------
//		0010 1110 => 1만 들어있는 것만 출력
		
		 
		int a = 10; //0000 1010
		int b = 12; //0000 1100
		
		System.out.println(a & b); //0000 1010 & 1100 1100 => 8
		System.out.println(a | b); //0000 1010 & 0000 1110 => 14
		System.out.println(a ^ b); //0000 1010 & 0000 0110 => 6
		
//		~0000 1010 => 1111 0101 => 부호비트가 1이므로 음수이고, 다시 2의 보수로 변환하면
//		 0000 1011 => 11
		System.out.println(~a); // -11
		
	}

}
